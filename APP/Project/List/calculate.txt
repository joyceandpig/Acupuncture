; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\calculate.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\calculate.d --cpu=Cortex-M3 --apcs=interwork -O0 -Otime -I..\Project -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Utilities\stm32_eval -I..\Utilities\stm32_eval\IIC -I..\Utilities\stm32_eval\SPI -I..\Utilities\stm32_eval\AD5933 -I..\Utilities\stm32_eval\wave -I..\Utilities\stm32_eval\delay -I..\Utilities\stm32_eval\calculate -I"D:\Program Files\MDK_5.11\ARM\RV31\INC" -I"D:\Program Files\MDK_5.11\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include" -I"D:\Program Files\MDK_5.11\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL -DIMPVALTEST -W --omf_browse=.\obj\calculate.crf ..\Utilities\stm32_eval\calculate\Calculate.c]
                          THUMB

                          AREA ||i.Arry_Get_CRC16||, CODE, READONLY, ALIGN=2

                  Arry_Get_CRC16 PROC
;;;585    *******************************************************************/
;;;586    uint16_t Arry_Get_CRC16(uint8_t *start_pos, uint8_t usDataLen)
000000  b570              PUSH     {r4-r6,lr}
;;;587    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;588      uint8_t uchCRCHi = 0xFF ;// 高CRC字节初始化 
000006  25ff              MOVS     r5,#0xff
;;;589      uint8_t uchCRCLo = 0xFF ;// 低CRC字节初始化 
000008  23ff              MOVS     r3,#0xff
;;;590      uint8_t uIndex ;// CRC循环中的索引 
;;;591       
;;;592      while (usDataLen--)// 传输消息缓冲区 
00000a  e009              B        |L1.32|
                  |L1.12|
;;;593      { 
;;;594        uIndex   = uchCRCLo ^ (*(start_pos++)) ;// 计算CRC 
00000c  f8120b01          LDRB     r0,[r2],#1
000010  ea800103          EOR      r1,r0,r3
;;;595        uchCRCLo = uchCRCHi ^ auchCRCLo[uIndex] ; 
000014  4806              LDR      r0,|L1.48|
000016  5c40              LDRB     r0,[r0,r1]
000018  ea800305          EOR      r3,r0,r5
;;;596        uchCRCHi = auchCRCHi[uIndex] ; 
00001c  4805              LDR      r0,|L1.52|
00001e  5c45              LDRB     r5,[r0,r1]
                  |L1.32|
000020  0020              MOVS     r0,r4                 ;592
000022  f1a40601          SUB      r6,r4,#1              ;592
000026  b2f4              UXTB     r4,r6                 ;592
000028  d1f0              BNE      |L1.12|
;;;597      } 
;;;598      return (uint16_t)((uchCRCHi << 8) | uchCRCLo); 
00002a  ea432005          ORR      r0,r3,r5,LSL #8
;;;599    }
00002e  bd70              POP      {r4-r6,pc}
;;;600    /******************************************************************
                          ENDP

                  |L1.48|
                          DCD      auchCRCLo
                  |L1.52|
                          DCD      auchCRCHi

                          AREA ||i.CloseAllOutPut||, CODE, READONLY, ALIGN=1

                  CloseAllOutPut PROC
;;;383    }
;;;384    void CloseAllOutPut(void)
000000  b510              PUSH     {r4,lr}
;;;385    {
;;;386      CloseChannelOutput();
000002  f7fffffe          BL       CloseChannelOutput
;;;387    }
000006  bd10              POP      {r4,pc}
;;;388    /* Private functions ---------------------------------------------------------*/
                          ENDP


                          AREA ||i.CloseChannelOutput||, CODE, READONLY, ALIGN=2

                  CloseChannelOutput PROC
;;;371    /****************************************************************************/
;;;372    static void CloseChannelOutput(void)
000000  b510              PUSH     {r4,lr}
;;;373    {
;;;374      uint8_t channel_number = 0;
000002  2400              MOVS     r4,#0
;;;375      urgstop = TRUE;
000004  2001              MOVS     r0,#1
000006  490d              LDR      r1,|L3.60|
000008  7008              STRB     r0,[r1,#0]
;;;376      ReadyToUpdata();    
00000a  f7fffffe          BL       ReadyToUpdata
;;;377      for (;channel_number < CH_SUM;channel_number++)
00000e  e00f              B        |L3.48|
                  |L3.16|
;;;378      {
;;;379    		SPI_SendData(channel_number << ChannelOffset,CLEARVALUE);// 依次关闭各个通道的DA电压输出
000010  f64f71ff          MOV      r1,#0xffff
000014  ea013004          AND      r0,r1,r4,LSL #12
000018  2100              MOVS     r1,#0
00001a  f7fffffe          BL       SPI_SendData
;;;380    		CH[channel_number].channel_open = FALSE;
00001e  2000              MOVS     r0,#0
000020  eb040184          ADD      r1,r4,r4,LSL #2
000024  4a06              LDR      r2,|L3.64|
000026  eb020181          ADD      r1,r2,r1,LSL #2
00002a  72c8              STRB     r0,[r1,#0xb]
00002c  1c60              ADDS     r0,r4,#1              ;377
00002e  b2c4              UXTB     r4,r0                 ;377
                  |L3.48|
000030  2c06              CMP      r4,#6                 ;377
000032  dbed              BLT      |L3.16|
;;;381    	}
;;;382    	UpdataDAOutput();	     // 更新DA电压输出值
000034  f7fffffe          BL       UpdataDAOutput
;;;383    }
000038  bd10              POP      {r4,pc}
;;;384    void CloseAllOutPut(void)
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
                          DCD      urgstop
                  |L3.64|
                          DCD      ||CH||

                          AREA ||i.ComputeChParameter||, CODE, READONLY, ALIGN=2

                  ComputeChParameter PROC
;;;531    *******************************************************************/
;;;532    void ComputeChParameter(uint8_t Clength,uint8_t *Cdata)
000000  b570              PUSH     {r4-r6,lr}
;;;533    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;534      static uint16_t func_code;
;;;535    	u32 JumpAddress;
;;;536    //	printf("compute ok\n");
;;;537    	ch_num = 6 - *(Cdata+BIT8);              //输出通道转置，1号变为6号，2号变为5号
000006  7a20              LDRB     r0,[r4,#8]
000008  f1c00006          RSB      r0,r0,#6
00000c  4933              LDR      r1,|L4.220|
00000e  7008              STRB     r0,[r1,#0]
;;;538    	ResetChannelParamer(ch_num);             //重置对应通道的计数值	
000010  4608              MOV      r0,r1
000012  7800              LDRB     r0,[r0,#0]  ; ch_num
000014  f7fffffe          BL       ResetChannelParamer
;;;539    	func_code = (uint16_t)(*(Cdata+BIT6)<<ShiftOffset)|(uint16_t)*(Cdata+BIT7);
000018  79e0              LDRB     r0,[r4,#7]
00001a  79a1              LDRB     r1,[r4,#6]
00001c  ea402001          ORR      r0,r0,r1,LSL #8
000020  492f              LDR      r1,|L4.224|
000022  8008              STRH     r0,[r1,#0]
;;;540    
;;;541    	if (func_code == Stop)                     //停止波形
000024  4608              MOV      r0,r1
000026  8800              LDRH     r0,[r0,#0]  ; func_code
000028  f5b07f82          CMP      r0,#0x104
00002c  d111              BNE      |L4.82|
;;;542    	{
;;;543    		CH[ch_num].channel_open = FALSE;
00002e  2000              MOVS     r0,#0
000030  492a              LDR      r1,|L4.220|
000032  7809              LDRB     r1,[r1,#0]  ; ch_num
000034  eb010181          ADD      r1,r1,r1,LSL #2
000038  4a2a              LDR      r2,|L4.228|
00003a  eb020181          ADD      r1,r2,r1,LSL #2
00003e  72c8              STRB     r0,[r1,#0xb]
;;;544    	  CH[ch_num].channel_stop_state = TRUE;
000040  2001              MOVS     r0,#1
000042  4926              LDR      r1,|L4.220|
000044  7809              LDRB     r1,[r1,#0]  ; ch_num
000046  eb010181          ADD      r1,r1,r1,LSL #2
00004a  eb020181          ADD      r1,r2,r1,LSL #2
00004e  7348              STRB     r0,[r1,#0xd]
000050  e043              B        |L4.218|
                  |L4.82|
;;;545    	}
;;;546    	else if (func_code == DownLoad_App)//IAP更新
000052  4823              LDR      r0,|L4.224|
000054  8800              LDRH     r0,[r0,#0]  ; func_code
000056  f5b07f83          CMP      r0,#0x106
00005a  d11a              BNE      |L4.146|
;;;547    	{
;;;548    		FLASH_Unlock();
00005c  f7fffffe          BL       FLASH_Unlock
;;;549    		FLASH_ErasePage(0x08004800);
000060  4821              LDR      r0,|L4.232|
000062  f7fffffe          BL       FLASH_ErasePage
;;;550    		FLASH_ProgramHalfWord(0x08004800,0x01);
000066  2101              MOVS     r1,#1
000068  481f              LDR      r0,|L4.232|
00006a  f7fffffe          BL       FLASH_ProgramHalfWord
;;;551    		FLASH_Lock();
00006e  f7fffffe          BL       FLASH_Lock
;;;552    		Config_Close();
000072  f7fffffe          BL       Config_Close
;;;553    		
;;;554    		JumpAddress = *(vu32*) (JumpBootAddress + 4);  //the address value
000076  f04f6000          MOV      r0,#0x8000000
00007a  6845              LDR      r5,[r0,#4]
;;;555    		/* Jump to user application */
;;;556    		Jump_To_Application = (pFunction) JumpAddress;
00007c  481b              LDR      r0,|L4.236|
00007e  6005              STR      r5,[r0,#0]  ; Jump_To_Application
;;;557    		/* Initialize user application's Stack Pointer */
;;;558    		__set_MSP(*(vu32*) JumpBootAddress);
000080  f04f6100          MOV      r1,#0x8000000
000084  6808              LDR      r0,[r1,#0]
000086  f7fffffe          BL       __set_MSP
;;;559    		Jump_To_Application();
00008a  4818              LDR      r0,|L4.236|
00008c  6800              LDR      r0,[r0,#0]  ; Jump_To_Application
00008e  4780              BLX      r0
000090  e023              B        |L4.218|
                  |L4.146|
;;;560    	}
;;;561    	else                                       //其他指令
;;;562    	{
;;;563    		if (func_code < 0x0105)   							//表示控制对象为波形
000092  4813              LDR      r0,|L4.224|
000094  8800              LDRH     r0,[r0,#0]  ; func_code
000096  f5b07f82          CMP      r0,#0x104
00009a  dc0e              BGT      |L4.186|
;;;564    		{		
;;;565    			CH[ch_num].function_code = func_code;     //赋值波形类型
00009c  4810              LDR      r0,|L4.224|
00009e  8800              LDRH     r0,[r0,#0]  ; func_code
0000a0  490e              LDR      r1,|L4.220|
0000a2  7809              LDRB     r1,[r1,#0]  ; ch_num
0000a4  eb010181          ADD      r1,r1,r1,LSL #2
0000a8  4a0e              LDR      r2,|L4.228|
0000aa  f8220021          STRH     r0,[r2,r1,LSL #2]
;;;566    			ConfigureChannelParamer(ch_num,Cdata);    //计算通道波形的参数
0000ae  4621              MOV      r1,r4
0000b0  480a              LDR      r0,|L4.220|
0000b2  7800              LDRB     r0,[r0,#0]  ; ch_num
0000b4  f7fffffe          BL       ConfigureChannelParamer
0000b8  e00f              B        |L4.218|
                  |L4.186|
;;;567    		}
;;;568    		else if ((func_code < 0x0223) && (func_code > 0x0200))//表示阻抗相关指令
0000ba  4809              LDR      r0,|L4.224|
0000bc  8800              LDRH     r0,[r0,#0]  ; func_code
0000be  f2402123          MOV      r1,#0x223
0000c2  4288              CMP      r0,r1
0000c4  da09              BGE      |L4.218|
0000c6  4806              LDR      r0,|L4.224|
0000c8  8800              LDRH     r0,[r0,#0]  ; func_code
0000ca  f5b07f00          CMP      r0,#0x200
0000ce  dd04              BLE      |L4.218|
;;;569          ImpVal(func_code,Cdata);
0000d0  4621              MOV      r1,r4
0000d2  4803              LDR      r0,|L4.224|
0000d4  8800              LDRH     r0,[r0,#0]  ; func_code
0000d6  f7fffffe          BL       ImpVal
                  |L4.218|
;;;570    	}	
;;;571    }
0000da  bd70              POP      {r4-r6,pc}
;;;572    /******************************************************************
                          ENDP

                  |L4.220|
                          DCD      ch_num
                  |L4.224|
                          DCD      func_code
                  |L4.228|
                          DCD      ||CH||
                  |L4.232|
                          DCD      0x08004800
                  |L4.236|
                          DCD      Jump_To_Application

                          AREA ||i.Config_Close||, CODE, READONLY, ALIGN=1

                  Config_Close PROC
;;;512    }
;;;513    static void Config_Close(void)
000000  b510              PUSH     {r4,lr}
;;;514    {
;;;515    	UartClose();
000002  f7fffffe          BL       UartClose
;;;516    	TimClose();
000006  f7fffffe          BL       TimClose
;;;517    	CloseChannelOutput();
00000a  f7fffffe          BL       CloseChannelOutput
;;;518    }
00000e  bd10              POP      {r4,pc}
;;;519    /******************************************************************
                          ENDP


                          AREA ||i.ConfigureChannelParamer||, CODE, READONLY, ALIGN=2

                  ConfigureChannelParamer PROC
;;;465    *******************************************************************/
;;;466    static void ConfigureChannelParamer(uint8_t channel_num,uint8_t *Pdata)
000000  b510              PUSH     {r4,lr}
;;;467    {
;;;468    	static uint16_t channel_frequency = 0;
;;;469    	
;;;470    	CH[channel_num].channel_open       = TRUE;	
000002  2201              MOVS     r2,#1
000004  eb000380          ADD      r3,r0,r0,LSL #2
000008  4c3a              LDR      r4,|L6.244|
00000a  eb040383          ADD      r3,r4,r3,LSL #2
00000e  72da              STRB     r2,[r3,#0xb]
;;;471    	CH[channel_num].channel_stop_state = FALSE;
000010  2200              MOVS     r2,#0
000012  eb000380          ADD      r3,r0,r0,LSL #2
000016  eb040383          ADD      r3,r4,r3,LSL #2
00001a  735a              STRB     r2,[r3,#0xd]
;;;472    	CH[channel_num].channel            = channel_num;
00001c  eb000280          ADD      r2,r0,r0,LSL #2
000020  4623              MOV      r3,r4
000022  eb030282          ADD      r2,r3,r2,LSL #2
000026  7290              STRB     r0,[r2,#0xa]
;;;473    	if(CH[channel_num].function_code   == 0x102 || \
000028  eb000280          ADD      r2,r0,r0,LSL #2
00002c  f8332022          LDRH     r2,[r3,r2,LSL #2]
000030  f5b27f81          CMP      r2,#0x102
000034  d007              BEQ      |L6.70|
;;;474    		 CH[channel_num].function_code   == 0x103)        //判定波形是否为复杂波形
000036  eb000280          ADD      r2,r0,r0,LSL #2
00003a  f8332022          LDRH     r2,[r3,r2,LSL #2]
00003e  f2401303          MOV      r3,#0x103
000042  429a              CMP      r2,r3
000044  d107              BNE      |L6.86|
                  |L6.70|
;;;475    		CH[channel_num].complex_status   = TRUE;
000046  2201              MOVS     r2,#1
000048  eb000380          ADD      r3,r0,r0,LSL #2
00004c  4c29              LDR      r4,|L6.244|
00004e  eb040383          ADD      r3,r4,r3,LSL #2
000052  749a              STRB     r2,[r3,#0x12]
000054  e006              B        |L6.100|
                  |L6.86|
;;;476    	else
;;;477    		CH[channel_num].complex_status   = FALSE;
000056  2200              MOVS     r2,#0
000058  eb000380          ADD      r3,r0,r0,LSL #2
00005c  4c25              LDR      r4,|L6.244|
00005e  eb040383          ADD      r3,r4,r3,LSL #2
000062  749a              STRB     r2,[r3,#0x12]
                  |L6.100|
;;;478    	
;;;479    	channel_frequency         = (uint16_t)*(Pdata+BIT9) << ShiftOffset|(uint16_t)*(Pdata+BIT10);
000064  7a8a              LDRB     r2,[r1,#0xa]
000066  7a4b              LDRB     r3,[r1,#9]
000068  ea422203          ORR      r2,r2,r3,LSL #8
00006c  4b22              LDR      r3,|L6.248|
00006e  801a              STRH     r2,[r3,#0]
;;;480    	CH[channel_num].peroid    = PEROID_COMPUTE_VALUE / channel_frequency;	   
000070  461a              MOV      r2,r3
000072  8812              LDRH     r2,[r2,#0]  ; channel_frequency
000074  f2427310          MOV      r3,#0x2710
000078  fb93f2f2          SDIV     r2,r3,r2
00007c  eb000380          ADD      r3,r0,r0,LSL #2
000080  4c1c              LDR      r4,|L6.244|
000082  eb040383          ADD      r3,r4,r3,LSL #2
000086  805a              STRH     r2,[r3,#2]
;;;481    	CH[channel_num].ss_peroid = WAVE_PEROID_MULTIPLE * CH[channel_num].peroid;
000088  eb000280          ADD      r2,r0,r0,LSL #2
00008c  4623              MOV      r3,r4
00008e  eb030282          ADD      r2,r3,r2,LSL #2
000092  8852              LDRH     r2,[r2,#2]
000094  eb020282          ADD      r2,r2,r2,LSL #2
000098  eb000380          ADD      r3,r0,r0,LSL #2
00009c  eb040383          ADD      r3,r4,r3,LSL #2
0000a0  809a              STRH     r2,[r3,#4]
;;;482    	CH[channel_num].scope     = *(Pdata+BIT11) * TO_DA_SCOPE_FACTOR;
0000a2  7aca              LDRB     r2,[r1,#0xb]
0000a4  0092              LSLS     r2,r2,#2
0000a6  eb000380          ADD      r3,r0,r0,LSL #2
0000aa  eb040383          ADD      r3,r4,r3,LSL #2
0000ae  80da              STRH     r2,[r3,#6]
;;;483    	
;;;484    	if (CH[channel_num].scope > DA_SCOPE_UP_LIMIT)
0000b0  eb000280          ADD      r2,r0,r0,LSL #2
0000b4  4623              MOV      r3,r4
0000b6  eb030282          ADD      r2,r3,r2,LSL #2
0000ba  88d2              LDRH     r2,[r2,#6]
0000bc  f5b27f7a          CMP      r2,#0x3e8
0000c0  dd06              BLE      |L6.208|
;;;485    		CH[channel_num].scope   = DA_SCOPE_UP_LIMIT;//对DA电压输出限幅（超过DA芯片的最大值1000后，DA将会没有输出
0000c2  f44f727a          MOV      r2,#0x3e8
0000c6  eb000380          ADD      r3,r0,r0,LSL #2
0000ca  eb040383          ADD      r3,r4,r3,LSL #2
0000ce  80da              STRH     r2,[r3,#6]
                  |L6.208|
;;;486    	if (CH[channel_num].peroid > PEROID_UP_LIMIT)
0000d0  eb000280          ADD      r2,r0,r0,LSL #2
0000d4  4b07              LDR      r3,|L6.244|
0000d6  eb030282          ADD      r2,r3,r2,LSL #2
0000da  8852              LDRH     r2,[r2,#2]
0000dc  f2413388          MOV      r3,#0x1388
0000e0  429a              CMP      r2,r3
0000e2  dd06              BLE      |L6.242|
;;;487    		CH[channel_num].peroid  = PEROID_UP_LIMIT;//对转换后的周期进行限制，防止发送的数据超过预定值后出错
0000e4  461a              MOV      r2,r3
0000e6  eb000380          ADD      r3,r0,r0,LSL #2
0000ea  4c02              LDR      r4,|L6.244|
0000ec  eb040383          ADD      r3,r4,r3,LSL #2
0000f0  805a              STRH     r2,[r3,#2]
                  |L6.242|
;;;488    }
0000f2  bd10              POP      {r4,pc}
;;;489    /* Private functions ---------------------------------------------------------*/
                          ENDP

                  |L6.244|
                          DCD      ||CH||
                  |L6.248|
                          DCD      channel_frequency

                          AREA ||i.DeQueue||, CODE, READONLY, ALIGN=1

                  DeQueue PROC
;;;256    *******************************************************************/
;;;257    uint8_t DeQueue(SqQueue *Q)
000000  b510              PUSH     {r4,lr}
;;;258    {
000002  4604              MOV      r4,r0
;;;259    	if (IsEmpty(Q))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       IsEmpty
00000a  b108              CBZ      r0,|L7.16|
;;;260    	{
;;;261    		return FALSE;
00000c  2000              MOVS     r0,#0
                  |L7.14|
;;;262    	}	
;;;263    	Q->front = (Q->front + 1)%CAPACITY;
;;;264    	Q->size--;
;;;265    	return TRUE;
;;;266    }
00000e  bd10              POP      {r4,pc}
                  |L7.16|
000010  f8b41402          LDRH     r1,[r4,#0x402]        ;263
000014  1c48              ADDS     r0,r1,#1              ;263
000016  17c1              ASRS     r1,r0,#31             ;263
000018  eb005191          ADD      r1,r0,r1,LSR #22      ;263
00001c  1289              ASRS     r1,r1,#10             ;263
00001e  eba02181          SUB      r1,r0,r1,LSL #10      ;263
000022  f8a41402          STRH     r1,[r4,#0x402]        ;263
000026  8820              LDRH     r0,[r4,#0]            ;264
000028  1e40              SUBS     r0,r0,#1              ;264
00002a  b200              SXTH     r0,r0                 ;264
00002c  8020              STRH     r0,[r4,#0]            ;264
00002e  2001              MOVS     r0,#1                 ;265
000030  e7ed              B        |L7.14|
;;;267    /******************************************************************
                          ENDP


                          AREA ||i.DisUrgentState||, CODE, READONLY, ALIGN=2

                  DisUrgentState PROC
;;;820    *******************************************************************/
;;;821    uint8_t DisUrgentState(void)//非急停状况（正常时）
000000  4803              LDR      r0,|L8.16|
;;;822    {
;;;823    	return !urgstop;             //返回当前状态是否处理急停
000002  7800              LDRB     r0,[r0,#0]  ; urgstop
000004  b908              CBNZ     r0,|L8.10|
000006  2001              MOVS     r0,#1
                  |L8.8|
;;;824    }
000008  4770              BX       lr
                  |L8.10|
00000a  2000              MOVS     r0,#0                 ;823
00000c  e7fc              B        |L8.8|
;;;825    /******************************************************************
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      urgstop

                          AREA ||i.EnQueue||, CODE, READONLY, ALIGN=1

                  EnQueue PROC
;;;232    /*************************环形队列 入队列操作***********************/
;;;233    uint8_t EnQueue(SqQueue *Q, uint8_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;234    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;235    	if (IsFull(Q))
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       IsFull
00000c  b108              CBZ      r0,|L9.18|
;;;236    	{
;;;237    		return FALSE;
00000e  2000              MOVS     r0,#0
                  |L9.16|
;;;238    	}	
;;;239    	Q->items[Q->rear] = data;
;;;240    	Q->size++;
;;;241    	Q->rear = (Q->rear + 1)%CAPACITY;
;;;242    	return TRUE;
;;;243    }
000010  bd70              POP      {r4-r6,pc}
                  |L9.18|
000012  f8b41404          LDRH     r1,[r4,#0x404]        ;239
000016  1ca0              ADDS     r0,r4,#2              ;239
000018  5445              STRB     r5,[r0,r1]            ;239
00001a  8820              LDRH     r0,[r4,#0]            ;240
00001c  1c40              ADDS     r0,r0,#1              ;240
00001e  b200              SXTH     r0,r0                 ;240
000020  8020              STRH     r0,[r4,#0]            ;240
000022  f8b41404          LDRH     r1,[r4,#0x404]        ;241
000026  1c48              ADDS     r0,r1,#1              ;241
000028  17c1              ASRS     r1,r0,#31             ;241
00002a  eb005191          ADD      r1,r0,r1,LSR #22      ;241
00002e  1289              ASRS     r1,r1,#10             ;241
000030  eba02181          SUB      r1,r0,r1,LSL #10      ;241
000034  f8a41404          STRH     r1,[r4,#0x404]        ;241
000038  2001              MOVS     r0,#1                 ;242
00003a  e7e9              B        |L9.16|
;;;244    /******************************************************************
                          ENDP


                          AREA ||i.ExecuteCmd||, CODE, READONLY, ALIGN=1

                  ExecuteCmd PROC
;;;838    *******************************************************************/
;;;839    void ExecuteCmd(uint8_t *EC_Data)//处理接收到的指令 
000000  b510              PUSH     {r4,lr}
;;;840    {
000002  4604              MOV      r4,r0
;;;841    	if (DisUrgentState())         //若设备处理正常状态时（非急停状态），就运行正常模式代码
000004  f7fffffe          BL       DisUrgentState
000008  b118              CBZ      r0,|L10.18|
;;;842    		RunNormal(EC_Data);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RunNormal
000010  e002              B        |L10.24|
                  |L10.18|
;;;843    	else                          //若设备处理急停状态，则运行急停模式代码
;;;844    		RunAbnormal(EC_Data);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RunAbnormal
                  |L10.24|
;;;845    }
000018  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.GetDataFromQueue||, CODE, READONLY, ALIGN=1

                  GetDataFromQueue PROC
;;;344    /**********************根据得到的帧头长度获取队列中指定长度数据，但是不移动front**********/
;;;345    uint8_t GetDataFromQueue(SqQueue *Q,uint8_t length_of_frame,uint8_t *data_of_frame)
000000  b570              PUSH     {r4-r6,lr}
;;;346    {
000002  4603              MOV      r3,r0
;;;347       uint16_t point,i;
;;;348       point = Q->front;
000004  f8b35402          LDRH     r5,[r3,#0x402]
;;;349       for (i = 0; i < length_of_frame; i++)
000008  2400              MOVS     r4,#0
00000a  e00d              B        |L11.40|
                  |L11.12|
;;;350       {
;;;351       	 *data_of_frame = Q->items[point];
00000c  1c98              ADDS     r0,r3,#2
00000e  5d40              LDRB     r0,[r0,r5]
000010  7010              STRB     r0,[r2,#0]
;;;352    	   point=(point+1)%CAPACITY;
000012  1c68              ADDS     r0,r5,#1
000014  17c6              ASRS     r6,r0,#31
000016  eb005696          ADD      r6,r0,r6,LSR #22
00001a  12b6              ASRS     r6,r6,#10
00001c  eba02686          SUB      r6,r0,r6,LSL #10
000020  b2b5              UXTH     r5,r6
;;;353    	   data_of_frame++;
000022  1c52              ADDS     r2,r2,#1
000024  1c60              ADDS     r0,r4,#1              ;349
000026  b284              UXTH     r4,r0                 ;349
                  |L11.40|
000028  428c              CMP      r4,r1                 ;349
00002a  dbef              BLT      |L11.12|
;;;354       }
;;;355       return TRUE;
00002c  2001              MOVS     r0,#1
;;;356    }
00002e  bd70              POP      {r4-r6,pc}
;;;357    
                          ENDP


                          AREA ||i.GetFrontDataFromQueue||, CODE, READONLY, ALIGN=1

                  GetFrontDataFromQueue PROC
;;;280    /***************************读取队头元素*****************************/
;;;281    uint8_t GetFrontDataFromQueue(SqQueue *Q)
000000  b510              PUSH     {r4,lr}
;;;282    {
000002  4604              MOV      r4,r0
;;;283    	if (IsEmpty(Q))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       IsEmpty
00000a  b108              CBZ      r0,|L12.16|
;;;284    	{
;;;285    		return FALSE;
00000c  2000              MOVS     r0,#0
                  |L12.14|
;;;286    	}
;;;287    	return Q->items[Q->front];
;;;288    }
00000e  bd10              POP      {r4,pc}
                  |L12.16|
000010  f8b41402          LDRH     r1,[r4,#0x402]        ;287
000014  1ca0              ADDS     r0,r4,#2              ;287
000016  5c40              LDRB     r0,[r0,r1]            ;287
000018  e7f9              B        |L12.14|
;;;289    
                          ENDP


                          AREA ||i.GetLengthOfQueue||, CODE, READONLY, ALIGN=1

                  GetLengthOfQueue PROC
;;;303    /*********************获取环形队列中数据长度***************************/
;;;304    uint8_t GetLengthOfQueue(SqQueue *Q)
000000  4601              MOV      r1,r0
;;;305    {
;;;306    	return (Q->rear-Q->front + CAPACITY)%CAPACITY;
000002  f8b10404          LDRH     r0,[r1,#0x404]
000006  f8b13402          LDRH     r3,[r1,#0x402]
00000a  1ac0              SUBS     r0,r0,r3
00000c  f5006280          ADD      r2,r0,#0x400
000010  17d0              ASRS     r0,r2,#31
000012  eb025090          ADD      r0,r2,r0,LSR #22
000016  1280              ASRS     r0,r0,#10
000018  eba22080          SUB      r0,r2,r0,LSL #10
00001c  b2c0              UXTB     r0,r0
;;;307    }
00001e  4770              BX       lr
;;;308    
                          ENDP


                          AREA ||i.IsCheckCodeRight||, CODE, READONLY, ALIGN=1

                  IsCheckCodeRight PROC
;;;633    *******************************************************************/
;;;634    uint8_t IsCheckCodeRight(uint8_t *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;635    {
000002  4604              MOV      r4,r0
;;;636      uint32_t checkcode = 0;
000004  2600              MOVS     r6,#0
;;;637      uint8_t len = *buf;
000006  7825              LDRB     r5,[r4,#0]
;;;638    	checkcode = Arry_Get_CRC16(buf,len-2);
000008  1ea8              SUBS     r0,r5,#2
00000a  b2c1              UXTB     r1,r0
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       Arry_Get_CRC16
000012  4606              MOV      r6,r0
;;;639      if (checkcode == ((*(buf+len-2)) << 8 | *(buf + len -1)))
000014  1960              ADDS     r0,r4,r5
000016  f8100c01          LDRB     r0,[r0,#-1]
00001a  1961              ADDS     r1,r4,r5
00001c  f8111c02          LDRB     r1,[r1,#-2]
000020  ea402001          ORR      r0,r0,r1,LSL #8
000024  42b0              CMP      r0,r6
000026  d101              BNE      |L14.44|
;;;640        return TRUE;
000028  2001              MOVS     r0,#1
                  |L14.42|
;;;641      else
;;;642        return FALSE;
;;;643    }
00002a  bd70              POP      {r4-r6,pc}
                  |L14.44|
00002c  2000              MOVS     r0,#0                 ;642
00002e  e7fc              B        |L14.42|
;;;644    /******************************************************************
                          ENDP


                          AREA ||i.IsEmpty||, CODE, READONLY, ALIGN=1

                  IsEmpty PROC
;;;213    /******************************判定队列是否为空队列**********************/
;;;214    static uint8_t IsEmpty(SqQueue *Q)
000000  4601              MOV      r1,r0
;;;215    {
;;;216    	return (Q->size <= CLEARVALUE)?TRUE:FALSE;
000002  f9b10000          LDRSH    r0,[r1,#0]
000006  2800              CMP      r0,#0
000008  dc01              BGT      |L15.14|
00000a  2001              MOVS     r0,#1
                  |L15.12|
;;;217    }
00000c  4770              BX       lr
                  |L15.14|
00000e  2000              MOVS     r0,#0                 ;216
000010  e7fc              B        |L15.12|
;;;218    
                          ENDP


                          AREA ||i.IsFrameLenRight||, CODE, READONLY, ALIGN=1

                  IsFrameLenRight PROC
;;;613    *******************************************************************/
;;;614    uint8_t IsFrameLenRight(SqQueue *Q)
000000  4601              MOV      r1,r0
;;;615    {
;;;616      if ((Q->items[Q->front] <= PRETREATSIZE) && (Q->items[Q->front] <= Q->size) && (Q->size > 0))
000002  f8b12402          LDRH     r2,[r1,#0x402]
000006  1c88              ADDS     r0,r1,#2
000008  5c80              LDRB     r0,[r0,r2]
00000a  2814              CMP      r0,#0x14
00000c  dc0d              BGT      |L16.42|
00000e  f8b12402          LDRH     r2,[r1,#0x402]
000012  1c88              ADDS     r0,r1,#2
000014  5c80              LDRB     r0,[r0,r2]
000016  f9b12000          LDRSH    r2,[r1,#0]
00001a  4290              CMP      r0,r2
00001c  dc05              BGT      |L16.42|
00001e  f9b10000          LDRSH    r0,[r1,#0]
000022  2800              CMP      r0,#0
000024  dd01              BLE      |L16.42|
;;;617        return TRUE;
000026  2001              MOVS     r0,#1
                  |L16.40|
;;;618      else
;;;619        return FALSE;
;;;620    }
000028  4770              BX       lr
                  |L16.42|
00002a  2000              MOVS     r0,#0                 ;619
00002c  e7fc              B        |L16.40|
;;;621    /******************************************************************
                          ENDP


                          AREA ||i.IsFull||, CODE, READONLY, ALIGN=1

                  IsFull PROC
;;;194    /****************************判定队列是否为满队列*************************/
;;;195    static uint8_t IsFull(SqQueue *Q)
000000  4601              MOV      r1,r0
;;;196    {
;;;197    	return (Q->size >= CAPACITY)?TRUE:FALSE;
000002  f9b10000          LDRSH    r0,[r1,#0]
000006  f5b06f80          CMP      r0,#0x400
00000a  db01              BLT      |L17.16|
00000c  2001              MOVS     r0,#1
                  |L17.14|
;;;198    }
00000e  4770              BX       lr
                  |L17.16|
000010  2000              MOVS     r0,#0                 ;197
000012  e7fc              B        |L17.14|
;;;199    
                          ENDP


                          AREA ||i.IsQueueRepeat||, CODE, READONLY, ALIGN=2

                  IsQueueRepeat PROC
;;;735    *******************************************************************/
;;;736    uint8_t IsQueueRepeat(void)
000000  b500              PUSH     {lr}
;;;737    {
;;;738      return RepeatOrderDeal(15,PretreatBuffer);
000002  4902              LDR      r1,|L18.12|
000004  200f              MOVS     r0,#0xf
000006  f7fffffe          BL       RepeatOrderDeal
;;;739    }
00000a  bd00              POP      {pc}
;;;740    /******************************************************************
                          ENDP

                  |L18.12|
                          DCD      PretreatBuffer

                          AREA ||i.LightLed||, CODE, READONLY, ALIGN=2

                  LightLed PROC
;;;173    *******************************************************************/
;;;174    void LightLed(uint16_t *count,LED_TypeDef LED_PORT)
000000  b570              PUSH     {r4-r6,lr}
;;;175    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;176      if (*count < LED_COUNT1)GPIO_LOW(GPIO_LED,LED_PORT);
000006  8820              LDRH     r0,[r4,#0]
000008  490d              LDR      r1,|L19.64|
00000a  8809              LDRH     r1,[r1,#0]  ; LED_COUNT1
00000c  4288              CMP      r0,r1
00000e  da04              BGE      |L19.26|
000010  4629              MOV      r1,r5
000012  480c              LDR      r0,|L19.68|
000014  f7fffffe          BL       GPIO_ResetBits
000018  e010              B        |L19.60|
                  |L19.26|
;;;177    	else if ((LED_COUNT1 <= *count) && (*count < LED_COUNT2))GPIO_HIGH(GPIO_LED,LED_PORT);
00001a  8820              LDRH     r0,[r4,#0]
00001c  4908              LDR      r1,|L19.64|
00001e  8809              LDRH     r1,[r1,#0]  ; LED_COUNT1
000020  4288              CMP      r0,r1
000022  db09              BLT      |L19.56|
000024  8820              LDRH     r0,[r4,#0]
000026  4908              LDR      r1,|L19.72|
000028  8809              LDRH     r1,[r1,#0]  ; LED_COUNT2
00002a  4288              CMP      r0,r1
00002c  da04              BGE      |L19.56|
00002e  4629              MOV      r1,r5
000030  4804              LDR      r0,|L19.68|
000032  f7fffffe          BL       GPIO_SetBits
000036  e001              B        |L19.60|
                  |L19.56|
;;;178    	else *count = CLEARVALUE;
000038  2000              MOVS     r0,#0
00003a  8020              STRH     r0,[r4,#0]
                  |L19.60|
;;;179    }
00003c  bd70              POP      {r4-r6,pc}
;;;180    
                          ENDP

00003e  0000              DCW      0x0000
                  |L19.64|
                          DCD      LED_COUNT1
                  |L19.68|
                          DCD      0x40011000
                  |L19.72|
                          DCD      LED_COUNT2

                          AREA ||i.RemoveFrameFromQueue||, CODE, READONLY, ALIGN=2

                  RemoveFrameFromQueue PROC
;;;657    *******************************************************************/
;;;658    void RemoveFrameFromQueue(SqQueue *Q)
000000  b510              PUSH     {r4,lr}
;;;659    {
000002  4604              MOV      r4,r0
;;;660      static uint8_t len = 0;
;;;661    	len = Q->items[Q->front];
000004  f8b41402          LDRH     r1,[r4,#0x402]
000008  1ca0              ADDS     r0,r4,#2
00000a  5c40              LDRB     r0,[r0,r1]
00000c  4907              LDR      r1,|L20.44|
00000e  7008              STRB     r0,[r1,#0]
;;;662    
;;;663      while(len--)
000010  e002              B        |L20.24|
                  |L20.18|
;;;664      {
;;;665        DeQueue(Q);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       DeQueue
                  |L20.24|
000018  4804              LDR      r0,|L20.44|
00001a  7801              LDRB     r1,[r0,#0]            ;663  ; len
00001c  7800              LDRB     r0,[r0,#0]            ;663  ; len
00001e  1e40              SUBS     r0,r0,#1              ;663
000020  4a02              LDR      r2,|L20.44|
000022  7010              STRB     r0,[r2,#0]            ;663
000024  2900              CMP      r1,#0                 ;663
000026  d1f4              BNE      |L20.18|
;;;666      }
;;;667    }
000028  bd10              POP      {r4,pc}
;;;668    /******************************************************************
                          ENDP

00002a  0000              DCW      0x0000
                  |L20.44|
                          DCD      len

                          AREA ||i.RepeatOrderDeal||, CODE, READONLY, ALIGN=2

                  RepeatOrderDeal PROC
;;;403    /********************************************重复命令处理***********************************/
;;;404    uint8_t RepeatOrderDeal(uint8_t Rlength,uint8_t *Rdata)
000000  b570              PUSH     {r4-r6,lr}
;;;405    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;406    	uint8_t rep_i,rep_si = 0,order_num = 0;
000006  2200              MOVS     r2,#0
000008  2500              MOVS     r5,#0
;;;407    
;;;408    	for (rep_i = 0; rep_i < Rlength - DISDATA_SUM; rep_i++)  //与上次指令进行比对
00000a  2100              MOVS     r1,#0
00000c  e009              B        |L21.34|
                  |L21.14|
;;;409    		if (order[rep_i] == *(Rdata+DATA_STA+rep_i))
00000e  481d              LDR      r0,|L21.132|
000010  5c46              LDRB     r6,[r0,r1]
000012  1da0              ADDS     r0,r4,#6
000014  5c40              LDRB     r0,[r0,r1]
000016  4286              CMP      r6,r0
000018  d101              BNE      |L21.30|
;;;410    			order_num++;
00001a  1c68              ADDS     r0,r5,#1
00001c  b2c5              UXTB     r5,r0
                  |L21.30|
00001e  1c48              ADDS     r0,r1,#1              ;408
000020  b2c1              UXTB     r1,r0                 ;408
                  |L21.34|
000022  f1a30008          SUB      r0,r3,#8              ;408
000026  4288              CMP      r0,r1                 ;408
000028  dcf1              BGT      |L21.14|
;;;411    
;;;412    
;;;413    	if (order_num == DATA_SUM)
00002a  2d06              CMP      r5,#6
00002c  d105              BNE      |L21.58|
;;;414    		rep_count++;     																	//数据全都相同，认为指令重复一次
00002e  4816              LDR      r0,|L21.136|
000030  7800              LDRB     r0,[r0,#0]  ; rep_count
000032  1c40              ADDS     r0,r0,#1
000034  4e14              LDR      r6,|L21.136|
000036  7030              STRB     r0,[r6,#0]
000038  e002              B        |L21.64|
                  |L21.58|
;;;415    	else 
;;;416    		rep_count = 0;
00003a  2000              MOVS     r0,#0
00003c  4e12              LDR      r6,|L21.136|
00003e  7030              STRB     r0,[r6,#0]
                  |L21.64|
;;;417    
;;;418      if ((order[0] == 0x02) && (order[1] == 0x21))rep_count = 0;
000040  4810              LDR      r0,|L21.132|
000042  7800              LDRB     r0,[r0,#0]  ; order
000044  2802              CMP      r0,#2
000046  d106              BNE      |L21.86|
000048  480e              LDR      r0,|L21.132|
00004a  7840              LDRB     r0,[r0,#1]  ; order
00004c  2821              CMP      r0,#0x21
00004e  d102              BNE      |L21.86|
000050  2000              MOVS     r0,#0
000052  4e0d              LDR      r6,|L21.136|
000054  7030              STRB     r0,[r6,#0]
                  |L21.86|
;;;419    
;;;420    	if (rep_count > 0)
000056  480c              LDR      r0,|L21.136|
000058  7800              LDRB     r0,[r0,#0]  ; rep_count
00005a  2800              CMP      r0,#0
00005c  dd02              BLE      |L21.100|
;;;421    	{
;;;422    		RepPar.time_start = TRUE;	//出现重复情况，则启动重复计时
00005e  2001              MOVS     r0,#1
000060  4e0a              LDR      r6,|L21.140|
000062  7030              STRB     r0,[r6,#0]
                  |L21.100|
;;;423    //		printf("指令重复\n");
;;;424    	}
;;;425    	
;;;426    	/*******************把本次接收的命令放入缓冲区内以供判断下一次命令的重复性**********/
;;;427    	for (rep_si = 0; rep_si < (Rlength - DISDATA_SUM); rep_si++)
000064  2200              MOVS     r2,#0
000066  e005              B        |L21.116|
                  |L21.104|
;;;428    		order[rep_si] = *(Rdata+DATA_SUM+rep_si);
000068  1da0              ADDS     r0,r4,#6
00006a  5c80              LDRB     r0,[r0,r2]
00006c  4e05              LDR      r6,|L21.132|
00006e  54b0              STRB     r0,[r6,r2]
000070  1c50              ADDS     r0,r2,#1              ;427
000072  b2c2              UXTB     r2,r0                 ;427
                  |L21.116|
000074  f1a30008          SUB      r0,r3,#8              ;427
000078  4290              CMP      r0,r2                 ;427
00007a  dcf5              BGT      |L21.104|
;;;429    	return rep_count;	
00007c  4802              LDR      r0,|L21.136|
00007e  7800              LDRB     r0,[r0,#0]  ; rep_count
;;;430    }
000080  bd70              POP      {r4-r6,pc}
;;;431    /******************************************************************
                          ENDP

000082  0000              DCW      0x0000
                  |L21.132|
                          DCD      order
                  |L21.136|
                          DCD      rep_count
                  |L21.140|
                          DCD      RepPar

                          AREA ||i.ResetChannelParamer||, CODE, READONLY, ALIGN=2

                  ResetChannelParamer PROC
;;;443    *******************************************************************/
;;;444    static void ResetChannelParamer(uint8_t channel_num)
000000  2100              MOVS     r1,#0
;;;445    {
;;;446    	CH[channel_num].wave_count = 0;
000002  eb000280          ADD      r2,r0,r0,LSL #2
000006  4b0a              LDR      r3,|L22.48|
000008  eb030282          ADD      r2,r3,r2,LSL #2
00000c  8111              STRH     r1,[r2,#8]
;;;447    	/***************如果接收到正确数据，则初始化断续、疏密波的标志位，使其重新开始*****************/
;;;448    	CH[channel_num].Iwave_count_flag = FALSE;
00000e  eb000280          ADD      r2,r0,r0,LSL #2
000012  eb030282          ADD      r2,r3,r2,LSL #2
000016  73d1              STRB     r1,[r2,#0xf]
;;;449    	CH[channel_num].Dwave_count_flag = FALSE;
000018  eb000280          ADD      r2,r0,r0,LSL #2
00001c  eb030282          ADD      r2,r3,r2,LSL #2
000020  7411              STRB     r1,[r2,#0x10]
;;;450    	/***************如果接收到正确数据，则初始化断续、疏密波的时间计数，使其重新开始***************/
;;;451    	CH[channel_num].time5s_count = 0;
000022  eb000280          ADD      r2,r0,r0,LSL #2
000026  eb030282          ADD      r2,r3,r2,LSL #2
00002a  7451              STRB     r1,[r2,#0x11]
;;;452    }
00002c  4770              BX       lr
;;;453    /******************************************************************
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      ||CH||

                          AREA ||i.ResetCmd||, CODE, READONLY, ALIGN=2

                  ResetCmd PROC
;;;753    *******************************************************************/
;;;754    void ResetCmd(uint8_t *Re_Data)//在急停状态下，可发送复位指令，使恢复到正常状态
000000  b570              PUSH     {r4-r6,lr}
;;;755    {
000002  4604              MOV      r4,r0
;;;756    	//如果是复位信号，则启动复位
;;;757    	uint16_t fun_code = (uint16_t)(*(Re_Data+BIT6)<<ShiftOffset)|(uint16_t)*(Re_Data+BIT7); 
000004  79e0              LDRB     r0,[r4,#7]
000006  79a1              LDRB     r1,[r4,#6]
000008  ea402501          ORR      r5,r0,r1,LSL #8
;;;758    	if (fun_code == Reset)                    //如果命令为复位
00000c  f2401005          MOV      r0,#0x105
000010  4285              CMP      r5,r0
000012  d109              BNE      |L23.40|
;;;759    	{
;;;760    		state_change(Normal);
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       state_change
;;;761    		urgstop = FALSE;
00001a  2000              MOVS     r0,#0
00001c  4903              LDR      r1,|L23.44|
00001e  7008              STRB     r0,[r1,#0]
;;;762    		GPIO_HIGH(GPIO_LED,LED4);
000020  2108              MOVS     r1,#8
000022  4803              LDR      r0,|L23.48|
000024  f7fffffe          BL       GPIO_SetBits
                  |L23.40|
;;;763    	}
;;;764    }
000028  bd70              POP      {r4-r6,pc}
;;;765    /******************************************************************
                          ENDP

00002a  0000              DCW      0x0000
                  |L23.44|
                          DCD      urgstop
                  |L23.48|
                          DCD      0x40011000

                          AREA ||i.RunAbnormal||, CODE, READONLY, ALIGN=2

                  RunAbnormal PROC
;;;801    *******************************************************************/
;;;802    void RunAbnormal(uint8_t *RA_Data)//运行急停状态
000000  b510              PUSH     {r4,lr}
;;;803    {
000002  4604              MOV      r4,r0
;;;804     ResetCmd(RA_Data);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       ResetCmd
;;;805     SendStatusReply(current_state);
00000a  4802              LDR      r0,|L24.20|
00000c  7800              LDRB     r0,[r0,#0]  ; current_state
00000e  f7fffffe          BL       SendStatusReply
;;;806    }
000012  bd10              POP      {r4,pc}
;;;807    /******************************************************************
                          ENDP

                  |L24.20|
                          DCD      current_state

                          AREA ||i.RunNormal||, CODE, READONLY, ALIGN=1

                  RunNormal PROC
;;;778    *******************************************************************/
;;;779    void RunNormal(uint8_t *RN_Data)             //运行非急停状态
000000  b510              PUSH     {r4,lr}
;;;780    {
000002  4604              MOV      r4,r0
;;;781    	if(!RepeatOrderDeal(*RN_Data,RN_Data))            //若与上一次指令不重复就进行指令转换，否则不转换，直接反馈
000004  7820              LDRB     r0,[r4,#0]
000006  4621              MOV      r1,r4
000008  f7fffffe          BL       RepeatOrderDeal
00000c  b918              CBNZ     r0,|L25.22|
;;;782    	{
;;;783    //		printf("指令不重复\n");
;;;784    		ComputeChParameter(*RN_Data,RN_Data);            //转换接收指令
00000e  7820              LDRB     r0,[r4,#0]
000010  4621              MOV      r1,r4
000012  f7fffffe          BL       ComputeChParameter
                  |L25.22|
;;;785    	}
;;;786      SendCmdReply(RN_Data,*RN_Data);
000016  7821              LDRB     r1,[r4,#0]
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       SendCmdReply
;;;787    }
00001e  bd10              POP      {r4,pc}
;;;788    /******************************************************************
                          ENDP


                          AREA ||i.ShiftFrontOfQueue||, CODE, READONLY, ALIGN=1

                  ShiftFrontOfQueue PROC
;;;322    /*************************队列的头元素向后移动一位，但是不获取元素,只移动front************/
;;;323    uint8_t ShiftFrontOfQueue(SqQueue *Q)
000000  b510              PUSH     {r4,lr}
;;;324    {
000002  4604              MOV      r4,r0
;;;325    	if (IsEmpty(Q))return FALSE;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       IsEmpty
00000a  b108              CBZ      r0,|L26.16|
00000c  2000              MOVS     r0,#0
                  |L26.14|
;;;326    	Q->size--;
;;;327    	Q->front = (Q->front+QueueOffset)%CAPACITY;
;;;328    	return TRUE;
;;;329    }
00000e  bd10              POP      {r4,pc}
                  |L26.16|
000010  8820              LDRH     r0,[r4,#0]            ;326
000012  1e40              SUBS     r0,r0,#1              ;326
000014  b200              SXTH     r0,r0                 ;326
000016  8020              STRH     r0,[r4,#0]            ;326
000018  f8b41402          LDRH     r1,[r4,#0x402]        ;327
00001c  1c48              ADDS     r0,r1,#1              ;327
00001e  17c1              ASRS     r1,r0,#31             ;327
000020  eb005191          ADD      r1,r0,r1,LSR #22      ;327
000024  1289              ASRS     r1,r1,#10             ;327
000026  eba02181          SUB      r1,r0,r1,LSL #10      ;327
00002a  f8a41402          STRH     r1,[r4,#0x402]        ;327
00002e  2001              MOVS     r0,#1                 ;328
000030  e7ed              B        |L26.14|
;;;330    
                          ENDP


                          AREA ||i.TimClose||, CODE, READONLY, ALIGN=2

                  TimClose PROC
;;;501    }
;;;502    static void TimClose(void)
000000  b510              PUSH     {r4,lr}
;;;503    {
;;;504        TIM_ITConfig(TIM2, TIM_IT_Update, DISABLE);
000002  2200              MOVS     r2,#0
000004  2101              MOVS     r1,#1
000006  0788              LSLS     r0,r1,#30
000008  f7fffffe          BL       TIM_ITConfig
;;;505        TIM_Cmd(TIM2, DISABLE);
00000c  2100              MOVS     r1,#0
00000e  f04f4080          MOV      r0,#0x40000000
000012  f7fffffe          BL       TIM_Cmd
;;;506    	
;;;507    	  TIM_ITConfig(TIM3, TIM_IT_Update, DISABLE);
000016  2200              MOVS     r2,#0
000018  2101              MOVS     r1,#1
00001a  4808              LDR      r0,|L27.60|
00001c  f7fffffe          BL       TIM_ITConfig
;;;508        TIM_Cmd(TIM3, DISABLE);
000020  2100              MOVS     r1,#0
000022  4806              LDR      r0,|L27.60|
000024  f7fffffe          BL       TIM_Cmd
;;;509    	
;;;510    	  TIM_ITConfig(TIM4, TIM_IT_Update, DISABLE);
000028  2200              MOVS     r2,#0
00002a  2101              MOVS     r1,#1
00002c  4804              LDR      r0,|L27.64|
00002e  f7fffffe          BL       TIM_ITConfig
;;;511        TIM_Cmd(TIM4, DISABLE);
000032  2100              MOVS     r1,#0
000034  4802              LDR      r0,|L27.64|
000036  f7fffffe          BL       TIM_Cmd
;;;512    }
00003a  bd10              POP      {r4,pc}
;;;513    static void Config_Close(void)
                          ENDP

                  |L27.60|
                          DCD      0x40000400
                  |L27.64|
                          DCD      0x40000800

                          AREA ||i.UartClose||, CODE, READONLY, ALIGN=2

                  UartClose PROC
;;;489    /* Private functions ---------------------------------------------------------*/
;;;490    static void UartClose(void)
000000  b510              PUSH     {r4,lr}
;;;491    {
;;;492        USART_Cmd(USART1, DISABLE);
000002  2100              MOVS     r1,#0
000004  4812              LDR      r0,|L28.80|
000006  f7fffffe          BL       USART_Cmd
;;;493    
;;;494        USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
00000a  2200              MOVS     r2,#0
00000c  f2407127          MOV      r1,#0x727
000010  480f              LDR      r0,|L28.80|
000012  f7fffffe          BL       USART_ITConfig
;;;495        USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);
000016  2200              MOVS     r2,#0
000018  f2405125          MOV      r1,#0x525
00001c  480c              LDR      r0,|L28.80|
00001e  f7fffffe          BL       USART_ITConfig
;;;496        USART_ITConfig(USART1, USART_IT_TC, DISABLE);
000022  2200              MOVS     r2,#0
000024  f2406126          MOV      r1,#0x626
000028  4809              LDR      r0,|L28.80|
00002a  f7fffffe          BL       USART_ITConfig
;;;497    
;;;498        USART_ClearITPendingBit(USART1, USART_IT_TXE);
00002e  f2407127          MOV      r1,#0x727
000032  4807              LDR      r0,|L28.80|
000034  f7fffffe          BL       USART_ClearITPendingBit
;;;499        USART_ClearITPendingBit(USART1, USART_IT_TC);
000038  f2406126          MOV      r1,#0x626
00003c  4804              LDR      r0,|L28.80|
00003e  f7fffffe          BL       USART_ClearITPendingBit
;;;500        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
000042  f2405125          MOV      r1,#0x525
000046  4802              LDR      r0,|L28.80|
000048  f7fffffe          BL       USART_ClearITPendingBit
;;;501    }
00004c  bd10              POP      {r4,pc}
;;;502    static void TimClose(void)
                          ENDP

00004e  0000              DCW      0x0000
                  |L28.80|
                          DCD      0x40013800

                          AREA ||i.WorkQueueData||, CODE, READONLY, ALIGN=2

                  WorkQueueData PROC
;;;681    *******************************************************************/
;;;682    uint8_t WorkQueueData(SqQueue *Q, uint8_t *IsGetWholeData)
000000  b570              PUSH     {r4-r6,lr}
;;;683    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;684      if (*IsGetWholeData)                												 //是否接收到完整数据
000006  7828              LDRB     r0,[r5,#0]
000008  2800              CMP      r0,#0
00000a  d039              BEQ      |L29.128|
;;;685      {
;;;686    //		printf("接收到完整数据串\n");
;;;687    //		printf("队列当前大小%d\n",Q->size);
;;;688    		system_start = 1;                    												//表示系统开始运行指令
00000c  2001              MOVS     r0,#1
00000e  491d              LDR      r1,|L29.132|
000010  7008              STRB     r0,[r1,#0]
;;;689    		if (IsFrameLenRight(Q))                                     //帧节的帧长数据不超限
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       IsFrameLenRight
000018  b358              CBZ      r0,|L29.114|
;;;690    		{
;;;691    //			printf("帧头不超限\n");
;;;692    //			printf("帧头为%d\n",Q->items[Q->front]);
;;;693    			memset(PretreatBuffer,'\0',PRETREATSIZE);
00001a  2114              MOVS     r1,#0x14
00001c  481a              LDR      r0,|L29.136|
00001e  f7fffffe          BL       __aeabi_memclr
;;;694    			GetDataFromQueue(Q,(Q->items[Q->front]),PretreatBuffer);//将队列的数据放入指定数组，
000022  f8b42402          LDRH     r2,[r4,#0x402]
000026  1ca0              ADDS     r0,r4,#2
000028  5c81              LDRB     r1,[r0,r2]
00002a  4a17              LDR      r2,|L29.136|
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       GetDataFromQueue
;;;695    			if (IsCheckCodeRight(PretreatBuffer))                   //校验码正确
000032  4815              LDR      r0,|L29.136|
000034  f7fffffe          BL       IsCheckCodeRight
000038  b158              CBZ      r0,|L29.82|
;;;696    			{
;;;697    //				printf("校验码正确\n");
;;;698    				RemoveFrameFromQueue(Q);                              //若校验正确，则把队列中该帧数据剔出来
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       RemoveFrameFromQueue
;;;699    				heart_time_count = 0;                                 //接收到正确数据后，心跳包计数清零
000040  2000              MOVS     r0,#0
000042  4912              LDR      r1,|L29.140|
000044  8008              STRH     r0,[r1,#0]
;;;700    				if (Q->size ==0) *IsGetWholeData = 0;       						//等待队列数据全部处理完全
000046  8820              LDRH     r0,[r4,#0]
000048  b908              CBNZ     r0,|L29.78|
00004a  2000              MOVS     r0,#0
00004c  7028              STRB     r0,[r5,#0]
                  |L29.78|
;;;701    				return TRUE;
00004e  2001              MOVS     r0,#1
                  |L29.80|
;;;702    			}
;;;703    			else                                                  //若校验错误，则说明帧头表示的一帧数据不正确，
;;;704    			{
;;;705    //				printf("校验码错误\n");
;;;706    				ErrPar.time_start = TRUE;                           //启动错误计时命令
;;;707    				errcode_count++;
;;;708    				DeQueue(Q);                                        //若检验错误，则删除该帧头的数据，然后再依次进行校验等判定
;;;709    				if (Q->size ==0) *IsGetWholeData = 0;       			//等待队列数据全部处理完全
;;;710    			} 
;;;711    		}
;;;712    		else
;;;713    		{
;;;714    //			printf("帧头超限\n");
;;;715    //			printf("帧头为%d\n",Q->items[Q->front]);
;;;716    			DeQueue(Q);                                       		//若帧长超限，则去除帧长位，继续进行各项判定     
;;;717    			if (Q->size ==0) *IsGetWholeData = 0;       						//等待队列数据全部处理完全
;;;718    		}
;;;719    	}
;;;720    	return FALSE;
;;;721    }
000050  bd70              POP      {r4-r6,pc}
                  |L29.82|
000052  2001              MOVS     r0,#1                 ;706
000054  490e              LDR      r1,|L29.144|
000056  7008              STRB     r0,[r1,#0]            ;706
000058  480e              LDR      r0,|L29.148|
00005a  7800              LDRB     r0,[r0,#0]            ;707  ; errcode_count
00005c  1c40              ADDS     r0,r0,#1              ;707
00005e  490d              LDR      r1,|L29.148|
000060  7008              STRB     r0,[r1,#0]            ;707
000062  4620              MOV      r0,r4                 ;708
000064  f7fffffe          BL       DeQueue
000068  8820              LDRH     r0,[r4,#0]            ;709
00006a  b948              CBNZ     r0,|L29.128|
00006c  2000              MOVS     r0,#0                 ;709
00006e  7028              STRB     r0,[r5,#0]            ;709
000070  e006              B        |L29.128|
                  |L29.114|
000072  4620              MOV      r0,r4                 ;716
000074  f7fffffe          BL       DeQueue
000078  8820              LDRH     r0,[r4,#0]            ;717
00007a  b908              CBNZ     r0,|L29.128|
00007c  2000              MOVS     r0,#0                 ;717
00007e  7028              STRB     r0,[r5,#0]            ;717
                  |L29.128|
000080  2000              MOVS     r0,#0                 ;720
000082  e7e5              B        |L29.80|
;;;722    /******************************************************************
                          ENDP

                  |L29.132|
                          DCD      system_start
                  |L29.136|
                          DCD      PretreatBuffer
                  |L29.140|
                          DCD      heart_time_count
                  |L29.144|
                          DCD      ErrPar
                  |L29.148|
                          DCD      errcode_count

                          AREA ||i.state_change||, CODE, READONLY, ALIGN=2

                  state_change PROC
;;;137    /******************************判定队列是否为空队列**********************/
;;;138    void state_change(AckState state_now)
000000  b510              PUSH     {r4,lr}
;;;139    {
000002  4604              MOV      r4,r0
;;;140      current_state = state_now;
000004  4819              LDR      r0,|L30.108|
000006  7004              STRB     r4,[r0,#0]
;;;141      
;;;142      if (ErrorCodeOverLimit == state_now)             /*****************增加闪烁频率**********/
000008  2c02              CMP      r4,#2
00000a  d10e              BNE      |L30.42|
;;;143      {
;;;144        LED_COUNT1 = LED_BASE_COUNT * LED_TWINKLE_SPEED;
00000c  f2427010          MOV      r0,#0x2710
000010  4917              LDR      r1,|L30.112|
000012  8008              STRH     r0,[r1,#0]
;;;145        LED_COUNT2 = LED_COUNT1 * LED_TWINKLE_SPEED;
000014  4608              MOV      r0,r1
000016  8800              LDRH     r0,[r0,#0]  ; LED_COUNT1
000018  f64f71ff          MOV      r1,#0xffff
00001c  ea010040          AND      r0,r1,r0,LSL #1
000020  4914              LDR      r1,|L30.116|
000022  8008              STRH     r0,[r1,#0]
;;;146        CloseAllOutPut();         //关闭所有通道输出
000024  f7fffffe          BL       CloseAllOutPut
000028  e01e              B        |L30.104|
                  |L30.42|
;;;147      }
;;;148      else if (OrderRepeatOverLimit == state_now || \
00002a  2c01              CMP      r4,#1
00002c  d001              BEQ      |L30.50|
;;;149    					TopDead == state_now)                    /******************减小闪烁频率**********/
00002e  2c03              CMP      r4,#3
000030  d10e              BNE      |L30.80|
                  |L30.50|
;;;150      {
;;;151        LED_COUNT1 = LED_BASE_COUNT / LED_TWINKLE_SPEED;
000032  f64010c4          MOV      r0,#0x9c4
000036  490e              LDR      r1,|L30.112|
000038  8008              STRH     r0,[r1,#0]
;;;152        LED_COUNT2 = LED_COUNT1 * LED_TWINKLE_SPEED;
00003a  4608              MOV      r0,r1
00003c  8800              LDRH     r0,[r0,#0]  ; LED_COUNT1
00003e  f64f71ff          MOV      r1,#0xffff
000042  ea010040          AND      r0,r1,r0,LSL #1
000046  490b              LDR      r1,|L30.116|
000048  8008              STRH     r0,[r1,#0]
;;;153        CloseAllOutPut();         //关闭所有通道输出
00004a  f7fffffe          BL       CloseAllOutPut
00004e  e00b              B        |L30.104|
                  |L30.80|
;;;154      }  
;;;155      else                                             /*****************恢复正常闪烁频率*******/
;;;156      {
;;;157        LED_COUNT1 = LED_BASE_COUNT;
000050  f2413088          MOV      r0,#0x1388
000054  4906              LDR      r1,|L30.112|
000056  8008              STRH     r0,[r1,#0]
;;;158        LED_COUNT2 = LED_COUNT1 * LED_TWINKLE_SPEED; 
000058  4608              MOV      r0,r1
00005a  8800              LDRH     r0,[r0,#0]  ; LED_COUNT1
00005c  f64f71ff          MOV      r1,#0xffff
000060  ea010040          AND      r0,r1,r0,LSL #1
000064  4903              LDR      r1,|L30.116|
000066  8008              STRH     r0,[r1,#0]
                  |L30.104|
;;;159      }
;;;160    }
000068  bd10              POP      {r4,pc}
;;;161    /******************************************************************
                          ENDP

00006a  0000              DCW      0x0000
                  |L30.108|
                          DCD      current_state
                  |L30.112|
                          DCD      LED_COUNT1
                  |L30.116|
                          DCD      LED_COUNT2

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  PretreatBuffer
                          %        20
                  Queue
                          %        1030
                  ||CH||
                          %        120

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  auchCRCLo
000000  00c18140          DCB      0x00,0xc1,0x81,0x40
000004  01c08041          DCB      0x01,0xc0,0x80,0x41
000008  01c08041          DCB      0x01,0xc0,0x80,0x41
00000c  00c18140          DCB      0x00,0xc1,0x81,0x40
000010  01c08041          DCB      0x01,0xc0,0x80,0x41
000014  00c18140          DCB      0x00,0xc1,0x81,0x40
000018  00c18140          DCB      0x00,0xc1,0x81,0x40
00001c  01c08041          DCB      0x01,0xc0,0x80,0x41
000020  01c08041          DCB      0x01,0xc0,0x80,0x41
000024  00c18140          DCB      0x00,0xc1,0x81,0x40
000028  00c18140          DCB      0x00,0xc1,0x81,0x40
00002c  01c08041          DCB      0x01,0xc0,0x80,0x41
000030  00c18140          DCB      0x00,0xc1,0x81,0x40
000034  01c08041          DCB      0x01,0xc0,0x80,0x41
000038  01c08041          DCB      0x01,0xc0,0x80,0x41
00003c  00c18140          DCB      0x00,0xc1,0x81,0x40
000040  01c08041          DCB      0x01,0xc0,0x80,0x41
000044  00c18140          DCB      0x00,0xc1,0x81,0x40
000048  00c18140          DCB      0x00,0xc1,0x81,0x40
00004c  01c08041          DCB      0x01,0xc0,0x80,0x41
000050  00c18140          DCB      0x00,0xc1,0x81,0x40
000054  01c08041          DCB      0x01,0xc0,0x80,0x41
000058  01c08041          DCB      0x01,0xc0,0x80,0x41
00005c  00c18140          DCB      0x00,0xc1,0x81,0x40
000060  00c18140          DCB      0x00,0xc1,0x81,0x40
000064  01c08041          DCB      0x01,0xc0,0x80,0x41
000068  01c08041          DCB      0x01,0xc0,0x80,0x41
00006c  00c18140          DCB      0x00,0xc1,0x81,0x40
000070  01c08041          DCB      0x01,0xc0,0x80,0x41
000074  00c18140          DCB      0x00,0xc1,0x81,0x40
000078  00c18140          DCB      0x00,0xc1,0x81,0x40
00007c  01c08041          DCB      0x01,0xc0,0x80,0x41
000080  01c08041          DCB      0x01,0xc0,0x80,0x41
000084  00c18140          DCB      0x00,0xc1,0x81,0x40
000088  00c18140          DCB      0x00,0xc1,0x81,0x40
00008c  01c08041          DCB      0x01,0xc0,0x80,0x41
000090  00c18140          DCB      0x00,0xc1,0x81,0x40
000094  01c08041          DCB      0x01,0xc0,0x80,0x41
000098  01c08041          DCB      0x01,0xc0,0x80,0x41
00009c  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  auchCRCHi
000100  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000104  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000108  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00010c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000110  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000114  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000118  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00011c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000120  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000124  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000128  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00012c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000130  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000134  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000138  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00013c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000140  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000144  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000148  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00014c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000150  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000154  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000158  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00015c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000160  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000164  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000168  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00016c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000170  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000174  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000178  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00017c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000180  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000184  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000188  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00018c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000190  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000194  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000198  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00019c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0001a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0001a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0001a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0001ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0001b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0001b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0001b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0001bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0001c0  50909151          DCB      0x50,0x90,0x91,0x51
0001c4  93535292          DCB      0x93,0x53,0x52,0x92
0001c8  96565797          DCB      0x96,0x56,0x57,0x97
0001cc  55959454          DCB      0x55,0x95,0x94,0x54
0001d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0001d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0001d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0001dc  99595898          DCB      0x99,0x59,0x58,0x98
0001e0  88484989          DCB      0x88,0x48,0x49,0x89
0001e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0001e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0001ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0001f0  44848545          DCB      0x44,0x84,0x85,0x45
0001f4  87474686          DCB      0x87,0x47,0x46,0x86
0001f8  82424383          DCB      0x82,0x42,0x43,0x83
0001fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  ch_num
000000  00                DCB      0x00
                  count
000001  000000            DCB      0x00,0x00,0x00
                  Jump_To_Application
                          DCD      0x00000000
                  current_state
000008  00                DCB      0x00
                  rep_count
000009  00                DCB      0x00
                  errcode_count
00000a  00                DCB      0x00
                  state_report_flag
00000b  00                DCB      0x00
                  urgstop
00000c  00                DCB      0x00
                  system_start
00000d  00                DCB      0x00
                  topdeath
00000e  00                DCB      0x00
                  get_whole_data
00000f  00                DCB      0x00
                  order
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  0000              DCB      0x00,0x00
                  LED_COUNT1
000016  1388              DCW      0x1388
                  LED_COUNT2
000018  2710              DCW      0x2710
                  report_time5s
00001a  0000              DCW      0x0000
                  heart_time_count
00001c  0000              DCW      0x0000
                  HeartBeat
00001e  0000              DCB      0x00,0x00
000020  0000              DCB      0x00,0x00
000022  0000              DCW      0x0000
                  RepPar
000024  0000              DCB      0x00,0x00
000026  0000              DCW      0x0000
                  ErrPar
000028  0000              DCB      0x00,0x00
00002a  0000              DCW      0x0000
                  ImpPar
00002c  00000000          DCB      0x00,0x00,0x00,0x00
000030  0000              DCW      0x0000
                  led_time_count
000032  0000              DCB      0x00,0x00
                  kAckBuf
000034  0e000200          DCB      0x0e,0x00,0x02,0x00
000038  01010200          DCB      0x01,0x01,0x02,0x00
00003c  ffffffff          DCB      0xff,0xff,0xff,0xff
000040  65fd0e00          DCB      0x65,0xfd,0x0e,0x00
000044  02000101          DCB      0x02,0x00,0x01,0x01
000048  0501ffff          DCB      0x05,0x01,0xff,0xff
00004c  ffff12c1          DCB      0xff,0xff,0x12,0xc1
000050  0e000200          DCB      0x0e,0x00,0x02,0x00
000054  01010502          DCB      0x01,0x01,0x05,0x02
000058  ffffffff          DCB      0xff,0xff,0xff,0xff
00005c  12850e00          DCB      0x12,0x85,0x0e,0x00
000060  02000101          DCB      0x02,0x00,0x01,0x01
000064  0503ffff          DCB      0x05,0x03,0xff,0xff
000068  ffffd288          DCB      0xff,0xff,0xd2,0x88
00006c  0e000200          DCB      0x0e,0x00,0x02,0x00
000070  01010221          DCB      0x01,0x01,0x02,0x21
000074  ffffffff          DCB      0xff,0xff,0xff,0xff
000078  d2880e00          DCB      0xd2,0x88,0x0e,0x00
00007c  02000101          DCB      0x02,0x00,0x01,0x01
000080  0221ffff          DCB      0x02,0x21,0xff,0xff
000084  ffffd288          DCB      0xff,0xff,0xd2,0x88
000088  0e000200          DCB      0x0e,0x00,0x02,0x00
00008c  01010223          DCB      0x01,0x01,0x02,0x23
000090  ffffffff          DCB      0xff,0xff,0xff,0xff
000094  d288              DCB      0xd2,0x88
                  channel_frequency
000096  0000              DCW      0x0000
                  func_code
000098  0000              DCB      0x00,0x00
                  len
00009a  00                DCB      0x00
