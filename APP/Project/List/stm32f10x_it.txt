; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_it.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 -Otime -I..\Project -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Utilities\stm32_eval -I..\Utilities\stm32_eval\IIC -I..\Utilities\stm32_eval\SPI -I..\Utilities\stm32_eval\AD5933 -I..\Utilities\stm32_eval\wave -I..\Utilities\stm32_eval\delay -I..\Utilities\stm32_eval\calculate -I"D:\Program Files\MDK_5.11\ARM\RV31\INC" -I"D:\Program Files\MDK_5.11\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include" -I"D:\Program Files\MDK_5.11\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL -DIMPVALTEST -W --omf_browse=.\obj\stm32f10x_it.crf stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
;;;93       */
;;;94     void BusFault_Handler(void)
000000  bf00              NOP      
                  |L1.2|
;;;95     {
;;;96       /* Go to infinite loop when Bus Fault exception occurs */
;;;97       while (1)
000002  e7fe              B        |L1.2|
;;;98       {
;;;99       }
;;;100    }
;;;101    
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;128      */
;;;129    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;130    {
;;;131    }
;;;132    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
;;;67       */
;;;68     void HardFault_Handler(void)
000000  bf00              NOP      
                  |L3.2|
;;;69     {
;;;70       /* Go to infinite loop when Hard Fault exception occurs */
;;;71       while (1)
000002  e7fe              B        |L3.2|
;;;72       {
;;;73       }
;;;74     }
;;;75     
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
;;;80       */
;;;81     void MemManage_Handler(void)
000000  bf00              NOP      
                  |L4.2|
;;;82     {
;;;83       /* Go to infinite loop when Memory Manage exception occurs */
;;;84       while (1)
000002  e7fe              B        |L4.2|
;;;85       {
;;;86       }
;;;87     }
;;;88     
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;58       */
;;;59     void NMI_Handler(void)
000000  4770              BX       lr
;;;60     {
;;;61     }
;;;62     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;137      */
;;;138    void PendSV_Handler(void)
000000  4770              BX       lr
;;;139    {
;;;140    }
;;;141    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;119      */
;;;120    void SVC_Handler(void)
000000  4770              BX       lr
;;;121    {
;;;122    }
;;;123    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;146      */
;;;147    void SysTick_Handler(void)
000000  4770              BX       lr
;;;148    {
;;;149    }
;;;150    
                          ENDP


                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM2_IRQHandler PROC
;;;169    *******************************************************************/
;;;170    void TIMx_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;171    {
;;;172    	/******作为计时使用，为波形变换时间提供依据,0.1ms进入一次*****/
;;;173     	if (TIM_GetITStatus(TIMx,TIM_IT_Update) != RESET)
000002  2101              MOVS     r1,#1
000004  0788              LSLS     r0,r1,#30
000006  f7fffffe          BL       TIM_GetITStatus
00000a  2800              CMP      r0,#0
00000c  d05e              BEQ      |L9.204|
;;;174    	{
;;;175    		TIM_ClearITPendingBit(TIMx, TIM_FLAG_Update);
00000e  2101              MOVS     r1,#1
000010  0788              LSLS     r0,r1,#30
000012  f7fffffe          BL       TIM_ClearITPendingBit
;;;176    		TIMx_timecount++;
000016  482e              LDR      r0,|L9.208|
000018  6800              LDR      r0,[r0,#0]  ; TIM2_timecount
00001a  1c40              ADDS     r0,r0,#1
00001c  492c              LDR      r1,|L9.208|
00001e  6008              STR      r0,[r1,#0]  ; TIM2_timecount
;;;177    		if (TIMx_timecount > Time5sCount)		          //定时一个5s时间
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]  ; TIM2_timecount
000024  f24c3150          MOV      r1,#0xc350
000028  4288              CMP      r0,r1
00002a  d927              BLS      |L9.124|
;;;178    		{
;;;179    			TIMx_timecount = 0;                    
00002c  2000              MOVS     r0,#0
00002e  4928              LDR      r1,|L9.208|
000030  6008              STR      r0,[r1,#0]  ; TIM2_timecount
;;;180    			for (ch_count = 0; ch_count < 6; ch_count++)//判定通道是否开启复杂波形，如果是，则对相应通道进行计数
000032  4928              LDR      r1,|L9.212|
000034  7008              STRB     r0,[r1,#0]
000036  e01d              B        |L9.116|
                  |L9.56|
;;;181    			{
;;;182    				if(CH[ch_count].complex_status)
000038  4826              LDR      r0,|L9.212|
00003a  7800              LDRB     r0,[r0,#0]  ; ch_count
00003c  eb000080          ADD      r0,r0,r0,LSL #2
000040  4925              LDR      r1,|L9.216|
000042  eb010080          ADD      r0,r1,r0,LSL #2
000046  7c80              LDRB     r0,[r0,#0x12]
000048  b178              CBZ      r0,|L9.106|
;;;183    					CH[ch_count].time5s_count++;     
00004a  4822              LDR      r0,|L9.212|
00004c  7800              LDRB     r0,[r0,#0]  ; ch_count
00004e  eb000080          ADD      r0,r0,r0,LSL #2
000052  eb010080          ADD      r0,r1,r0,LSL #2
000056  7c40              LDRB     r0,[r0,#0x11]
000058  1c40              ADDS     r0,r0,#1
00005a  491e              LDR      r1,|L9.212|
00005c  7809              LDRB     r1,[r1,#0]  ; ch_count
00005e  eb010181          ADD      r1,r1,r1,LSL #2
000062  4a1d              LDR      r2,|L9.216|
000064  eb020181          ADD      r1,r2,r1,LSL #2
000068  7448              STRB     r0,[r1,#0x11]
                  |L9.106|
00006a  481a              LDR      r0,|L9.212|
00006c  7800              LDRB     r0,[r0,#0]            ;180  ; ch_count
00006e  1c40              ADDS     r0,r0,#1              ;180
000070  4918              LDR      r1,|L9.212|
000072  7008              STRB     r0,[r1,#0]            ;180
                  |L9.116|
000074  4817              LDR      r0,|L9.212|
000076  7800              LDRB     r0,[r0,#0]            ;180  ; ch_count
000078  2806              CMP      r0,#6                 ;180
00007a  dbdd              BLT      |L9.56|
                  |L9.124|
;;;184    			}   
;;;185    		}
;;;186    		for (ch_count = 0; ch_count < 6; ch_count++)//如果通道开启，则对通道的基本波形时间计数
00007c  2000              MOVS     r0,#0
00007e  4915              LDR      r1,|L9.212|
000080  7008              STRB     r0,[r1,#0]
000082  e01d              B        |L9.192|
                  |L9.132|
;;;187    		{
;;;188    			if(CH[ch_count].channel_open)
000084  4813              LDR      r0,|L9.212|
000086  7800              LDRB     r0,[r0,#0]  ; ch_count
000088  eb000080          ADD      r0,r0,r0,LSL #2
00008c  4912              LDR      r1,|L9.216|
00008e  eb010080          ADD      r0,r1,r0,LSL #2
000092  7ac0              LDRB     r0,[r0,#0xb]
000094  b178              CBZ      r0,|L9.182|
;;;189    				CH[ch_count].wave_count++;
000096  480f              LDR      r0,|L9.212|
000098  7800              LDRB     r0,[r0,#0]  ; ch_count
00009a  eb000080          ADD      r0,r0,r0,LSL #2
00009e  eb010080          ADD      r0,r1,r0,LSL #2
0000a2  8900              LDRH     r0,[r0,#8]
0000a4  1c40              ADDS     r0,r0,#1
0000a6  490b              LDR      r1,|L9.212|
0000a8  7809              LDRB     r1,[r1,#0]  ; ch_count
0000aa  eb010181          ADD      r1,r1,r1,LSL #2
0000ae  4a0a              LDR      r2,|L9.216|
0000b0  eb020181          ADD      r1,r2,r1,LSL #2
0000b4  8108              STRH     r0,[r1,#8]
                  |L9.182|
0000b6  4807              LDR      r0,|L9.212|
0000b8  7800              LDRB     r0,[r0,#0]            ;186  ; ch_count
0000ba  1c40              ADDS     r0,r0,#1              ;186
0000bc  4905              LDR      r1,|L9.212|
0000be  7008              STRB     r0,[r1,#0]            ;186
                  |L9.192|
0000c0  4804              LDR      r0,|L9.212|
0000c2  7800              LDRB     r0,[r0,#0]            ;186  ; ch_count
0000c4  2806              CMP      r0,#6                 ;186
0000c6  dbdd              BLT      |L9.132|
;;;190    		}
;;;191    		WaveWork();//产生波形的函数
0000c8  f7fffffe          BL       WaveWork
                  |L9.204|
;;;192    	}
;;;193    }
0000cc  bd10              POP      {r4,pc}
;;;194    /******************************************************************
                          ENDP

0000ce  0000              DCW      0x0000
                  |L9.208|
                          DCD      TIM2_timecount
                  |L9.212|
                          DCD      ch_count
                  |L9.216|
                          DCD      ||CH||

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;206    *******************************************************************/
;;;207    void TIMy_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;208    {
;;;209    	/******作为计时使用，并为定时状态报告和心跳检测提供时间,0.1ms进入一次*****/
;;;210     	if (TIM_GetITStatus(TIMy,TIM_IT_Update) != RESET)
000002  2101              MOVS     r1,#1
000004  483a              LDR      r0,|L10.240|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  2800              CMP      r0,#0
00000c  d06f              BEQ      |L10.238|
;;;211    	{
;;;212    		TIM_ClearITPendingBit(TIMy, TIM_FLAG_Update);
00000e  2101              MOVS     r1,#1
000010  4837              LDR      r0,|L10.240|
000012  f7fffffe          BL       TIM_ClearITPendingBit
;;;213        TIMy_timecount++;
000016  4837              LDR      r0,|L10.244|
000018  6800              LDR      r0,[r0,#0]  ; TIM3_timecount
00001a  1c40              ADDS     r0,r0,#1
00001c  4935              LDR      r1,|L10.244|
00001e  6008              STR      r0,[r1,#0]  ; TIM3_timecount
;;;214    		if (TIMy_timecount > Time5sCount)		 //定时一个5s时间
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]  ; TIM3_timecount
000024  f24c3150          MOV      r1,#0xc350
000028  4288              CMP      r0,r1
00002a  d921              BLS      |L10.112|
;;;215    		{
;;;216          TIMy_timecount = 0; 	
00002c  2000              MOVS     r0,#0
00002e  4931              LDR      r1,|L10.244|
000030  6008              STR      r0,[r1,#0]  ; TIM3_timecount
;;;217    			
;;;218          report_time5s++;
000032  4831              LDR      r0,|L10.248|
000034  8800              LDRH     r0,[r0,#0]  ; report_time5s
000036  1c40              ADDS     r0,r0,#1
000038  492f              LDR      r1,|L10.248|
00003a  8008              STRH     r0,[r1,#0]
;;;219          if (report_time5s > StateReportCount)  //状态报告的时间控制
00003c  4608              MOV      r0,r1
00003e  8800              LDRH     r0,[r0,#0]  ; report_time5s
000040  2800              CMP      r0,#0
000042  dd04              BLE      |L10.78|
;;;220    			{
;;;221    				report_time5s = 0;
000044  2000              MOVS     r0,#0
000046  8008              STRH     r0,[r1,#0]
;;;222            state_report_flag = TRUE;	         //启动状态反馈
000048  2001              MOVS     r0,#1
00004a  492c              LDR      r1,|L10.252|
00004c  7008              STRB     r0,[r1,#0]
                  |L10.78|
;;;223    			}
;;;224    			
;;;225    			heart_time_count++;
00004e  482c              LDR      r0,|L10.256|
000050  8800              LDRH     r0,[r0,#0]  ; heart_time_count
000052  1c40              ADDS     r0,r0,#1
000054  492a              LDR      r1,|L10.256|
000056  8008              STRH     r0,[r1,#0]
;;;226          if(heart_time_count > MAX_HEART_TIME) //心跳检测最大等待时间
000058  4608              MOV      r0,r1
00005a  8800              LDRH     r0,[r0,#0]  ; heart_time_count
00005c  2805              CMP      r0,#5
00005e  dd07              BLE      |L10.112|
;;;227          {
;;;228            heart_time_count = 0;
000060  2000              MOVS     r0,#0
000062  8008              STRH     r0,[r1,#0]
;;;229    				if (system_start)
000064  4827              LDR      r0,|L10.260|
000066  7800              LDRB     r0,[r0,#0]  ; system_start
000068  b110              CBZ      r0,|L10.112|
;;;230    				{
;;;231    				topdeath = TRUE;
00006a  2001              MOVS     r0,#1
00006c  4926              LDR      r1,|L10.264|
00006e  7008              STRB     r0,[r1,#0]
                  |L10.112|
;;;232    				}
;;;233          }
;;;234    		}		
;;;235    	if (RepPar.time_start) //命令重复次数检测，规定时间内重复次数超过设定数值,则认为重复超限，急停设备
000070  4826              LDR      r0,|L10.268|
000072  7800              LDRB     r0,[r0,#0]  ; RepPar
000074  b180              CBZ      r0,|L10.152|
;;;236    	{
;;;237    		 RepPar.time_count++;
000076  4825              LDR      r0,|L10.268|
000078  8840              LDRH     r0,[r0,#2]  ; RepPar
00007a  1c40              ADDS     r0,r0,#1
00007c  4923              LDR      r1,|L10.268|
00007e  8048              STRH     r0,[r1,#2]
;;;238    		 if (RepPar.time_count > RepTimeLit) //到达重复命令预定时间
000080  4608              MOV      r0,r1
000082  8840              LDRH     r0,[r0,#2]  ; RepPar
000084  f2413188          MOV      r1,#0x1388
000088  4288              CMP      r0,r1
00008a  dd05              BLE      |L10.152|
;;;239    		 {
;;;240    		 	RepPar.time_limit = TRUE;
00008c  2001              MOVS     r0,#1
00008e  491f              LDR      r1,|L10.268|
000090  7048              STRB     r0,[r1,#1]
;;;241    			RepPar.time_count = 0;
000092  2000              MOVS     r0,#0
000094  8048              STRH     r0,[r1,#2]
;;;242    			RepPar.time_start = FALSE;
000096  7008              STRB     r0,[r1,#0]
                  |L10.152|
;;;243    		 }
;;;244    	}
;;;245    	if (ErrPar.time_start) //命令错误次数检测，规定时间内错误次数超过设定数值,则认为错误超限，急停设备
000098  481d              LDR      r0,|L10.272|
00009a  7800              LDRB     r0,[r0,#0]  ; ErrPar
00009c  b180              CBZ      r0,|L10.192|
;;;246    	{
;;;247    		 ErrPar.time_count++;
00009e  481c              LDR      r0,|L10.272|
0000a0  8840              LDRH     r0,[r0,#2]  ; ErrPar
0000a2  1c40              ADDS     r0,r0,#1
0000a4  491a              LDR      r1,|L10.272|
0000a6  8048              STRH     r0,[r1,#2]
;;;248    
;;;249    		 if (ErrPar.time_count > ErrTimeLit) //到达错误命令预定时间
0000a8  4608              MOV      r0,r1
0000aa  8840              LDRH     r0,[r0,#2]  ; ErrPar
0000ac  f2413188          MOV      r1,#0x1388
0000b0  4288              CMP      r0,r1
0000b2  dd05              BLE      |L10.192|
;;;250    		 {
;;;251    		 	ErrPar.time_limit = TRUE;
0000b4  2001              MOVS     r0,#1
0000b6  4916              LDR      r1,|L10.272|
0000b8  7048              STRB     r0,[r1,#1]
;;;252    			ErrPar.time_count = 0;
0000ba  2000              MOVS     r0,#0
0000bc  8048              STRH     r0,[r1,#2]
;;;253    			ErrPar.time_start = FALSE;
0000be  7008              STRB     r0,[r1,#0]
                  |L10.192|
;;;254    		 }	
;;;255    	}
;;;256      if (ImpPar.time_start)  //阻抗采集限制时间，超过一定时间没有得到数据返回，则跳过该次采集
0000c0  4814              LDR      r0,|L10.276|
0000c2  7800              LDRB     r0,[r0,#0]  ; ImpPar
0000c4  b170              CBZ      r0,|L10.228|
;;;257      {
;;;258        ImpPar.time_count++;
0000c6  4813              LDR      r0,|L10.276|
0000c8  8880              LDRH     r0,[r0,#4]  ; ImpPar
0000ca  1c40              ADDS     r0,r0,#1
0000cc  4911              LDR      r1,|L10.276|
0000ce  8088              STRH     r0,[r1,#4]
;;;259        if (ImpPar.time_count > ImpValTimeLit)
0000d0  4608              MOV      r0,r1
0000d2  8880              LDRH     r0,[r0,#4]  ; ImpPar
0000d4  f5b07f7a          CMP      r0,#0x3e8
0000d8  dd04              BLE      |L10.228|
;;;260        {
;;;261          ImpPar.time_limit = TRUE;
0000da  2001              MOVS     r0,#1
0000dc  7048              STRB     r0,[r1,#1]
;;;262          ImpPar.time_count = 0;
0000de  2000              MOVS     r0,#0
0000e0  8088              STRH     r0,[r1,#4]
;;;263          ImpPar.time_start = FALSE;
0000e2  7008              STRB     r0,[r1,#0]
                  |L10.228|
;;;264        }
;;;265      }
;;;266    	led_time_count++;				//指示灯计时器	
0000e4  480c              LDR      r0,|L10.280|
0000e6  8800              LDRH     r0,[r0,#0]  ; led_time_count
0000e8  1c40              ADDS     r0,r0,#1
0000ea  490b              LDR      r1,|L10.280|
0000ec  8008              STRH     r0,[r1,#0]
                  |L10.238|
;;;267    	}
;;;268    }
0000ee  bd10              POP      {r4,pc}
;;;269    
                          ENDP

                  |L10.240|
                          DCD      0x40000400
                  |L10.244|
                          DCD      TIM3_timecount
                  |L10.248|
                          DCD      report_time5s
                  |L10.252|
                          DCD      state_report_flag
                  |L10.256|
                          DCD      heart_time_count
                  |L10.260|
                          DCD      system_start
                  |L10.264|
                          DCD      topdeath
                  |L10.268|
                          DCD      RepPar
                  |L10.272|
                          DCD      ErrPar
                  |L10.276|
                          DCD      ImpPar
                  |L10.280|
                          DCD      led_time_count

                          AREA ||i.TIM4_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM4_IRQHandler PROC
;;;285    *******************************************************************/
;;;286    void TIMz_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;287    {
;;;288    	/******作为计时使用，0.1ms进入一次*****/
;;;289      if (TIM_GetITStatus(TIMz,TIM_IT_Update) != RESET)
000002  2101              MOVS     r1,#1
000004  480c              LDR      r0,|L11.56|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b1a0              CBZ      r0,|L11.54|
;;;290    	{
;;;291    		TIM_ClearITPendingBit(TIMz, TIM_FLAG_Update);
00000c  2101              MOVS     r1,#1
00000e  480a              LDR      r0,|L11.56|
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;292        if ((TIMz_timecount++) > us100(4))
000014  4909              LDR      r1,|L11.60|
000016  6808              LDR      r0,[r1,#0]  ; TIM4_timecount
000018  1c41              ADDS     r1,r0,#1
00001a  4a08              LDR      r2,|L11.60|
00001c  6011              STR      r1,[r2,#0]  ; TIM4_timecount
00001e  2804              CMP      r0,#4
000020  d909              BLS      |L11.54|
;;;293        {
;;;294            TIM_Cmd(TIMz,DISABLE);
000022  2100              MOVS     r1,#0
000024  4804              LDR      r0,|L11.56|
000026  f7fffffe          BL       TIM_Cmd
;;;295            TIMz_timecount = 0;
00002a  2000              MOVS     r0,#0
00002c  4903              LDR      r1,|L11.60|
00002e  6008              STR      r0,[r1,#0]  ; TIM4_timecount
;;;296    				get_whole_data = 1;
000030  2001              MOVS     r0,#1
000032  4903              LDR      r1,|L11.64|
000034  7008              STRB     r0,[r1,#0]
                  |L11.54|
;;;297    		}			
;;;298    	}
;;;299    }
000036  bd10              POP      {r4,pc}
;;;300    /******************************************************************
                          ENDP

                  |L11.56|
                          DCD      0x40000800
                  |L11.60|
                          DCD      TIM4_timecount
                  |L11.64|
                          DCD      get_whole_data

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;312    *******************************************************************/
;;;313    void USARTx_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;314    {	
;;;315    if (USART_GetITStatus(USART1,USART_IT_RXNE) != RESET)
000002  f2405125          MOV      r1,#0x525
000006  480f              LDR      r0,|L12.68|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b1c0              CBZ      r0,|L12.64|
;;;316    {
;;;317    	EnQueue(&Queue,USART_ReceiveData(USARTx));           	/*  把串口接收的数据放入环形缓冲区   */
00000e  480d              LDR      r0,|L12.68|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c4              UXTB     r4,r0
000016  4621              MOV      r1,r4
000018  480b              LDR      r0,|L12.72|
00001a  f7fffffe          BL       EnQueue
;;;318    	USART_ClearITPendingBit(USART1,USART_IT_RXNE); 
00001e  f2405125          MOV      r1,#0x525
000022  4808              LDR      r0,|L12.68|
000024  f7fffffe          BL       USART_ClearITPendingBit
;;;319    	TIM_Cmd(TIMz,DISABLE);
000028  2100              MOVS     r1,#0
00002a  4808              LDR      r0,|L12.76|
00002c  f7fffffe          BL       TIM_Cmd
;;;320    	TIM_SetCounter(TIMz,0);
000030  2100              MOVS     r1,#0
000032  4806              LDR      r0,|L12.76|
000034  f7fffffe          BL       TIM_SetCounter
;;;321    	TIM_Cmd(TIMz,ENABLE);
000038  2101              MOVS     r1,#1
00003a  4804              LDR      r0,|L12.76|
00003c  f7fffffe          BL       TIM_Cmd
                  |L12.64|
;;;322    }	
;;;323    }
000040  bd10              POP      {r4,pc}
;;;324    /******************************************************************************/
                          ENDP

000042  0000              DCW      0x0000
                  |L12.68|
                          DCD      0x40013800
                  |L12.72|
                          DCD      Queue
                  |L12.76|
                          DCD      0x40000800

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
;;;106      */
;;;107    void UsageFault_Handler(void)
000000  bf00              NOP      
                  |L13.2|
;;;108    {
;;;109      /* Go to infinite loop when Usage Fault exception occurs */
;;;110      while (1)
000002  e7fe              B        |L13.2|
;;;111      {
;;;112      }
;;;113    }
;;;114    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  kAckBuf
                          %        98

                          AREA ||.data||, DATA, ALIGN=2

                  order
                          DCD      0x00000000
000004  0000              DCB      0x00,0x00
                  ch_num
000006  00                DCB      0x00
                  count
000007  00                DCB      0x00
                  ch_count
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  TIM2_timecount
                          DCD      0x00000000
                  TIM3_timecount
                          DCD      0x00000000
                  TIM4_timecount
                          DCD      0x00000000
